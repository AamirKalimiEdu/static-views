#          Copyright Tom Westerhout 2017.
# Distributed under the Boost Software License, Version 1.0.
#    (See accompanying file LICENSE_1_0.txt or copy at
#          http://www.boost.org/LICENSE_1_0.txt)

import "class" : new ;
import common ;
import notfile ;
import path ;
import property-set ;
import type ;

#
# How it works
# ------------
#
# Boost.Build knows which commands to invoke with different compilers on
# different host operating systems. So it seems like a good idea to let b2
# compile the sources, and Python will measure the memory usage, do statistics
# and save the results.
#
# It is easy to invoke b2 from Python. What's difficult is to determine where b2
# stores the results without hardcoding the paths. From Boost.Build's FAQ:
#
# Q: How do I get the current value of feature in Jamfile?
# A: This is not possible, since Jamfile does not have "current" value of any
#    feature, be it toolset, build variant or anything else. ...
#
# To work around this we need a trick. If we want to know where target A will be
# saved to, we create a notfile rule A_fake with the same sources, requirements
# etc. as A. The generaring rule gets the requirements as an argument. From
# them, we can construct the property-set, and all the rest follows.
#



# ----------------------------- Preparation work ----------------------------- #

# Additional requirements for the measure_memory target.  The tool uses a second
# thread to measure memory usage, we thus need the multithreading support.
local _measure_memory_requirements = 
    <threading>multi ;

# Create a tool that measures memory usage of a command.
exe measure_memory : measure_memory.cpp
                   : $(_measure_memory_requirements)
                   ;
explicit measure_memory ;

rule _get-measure-memory-binary ( target : sources + : requirements * )
{
    # Construct a property-set from a list of requirements
    local xs   = [ property-set.create $(requirements) ] ;

    # Extract the path where the targets would be created
    # target-path actually returns a list consisting of a path and a boolean,
    # but we're only interested in the path part.
    local path = [ $(xs).target-path ] ;
    path = $(path[1]) ;

    # Convert the to native format and prepend bin/.  First of
    # get_measure_memory_bin sources is measure_memory, i.e. 
    # the executable name itself. 
    ECHO "get_measure_memory_bin:"
        [ path.native bin/$(path)/$(sources[1]:G=) ] ;
}

# Rule that prints the path to the measure_memory utility. We also make
# measure_memory itself a dependency of get_measure_memory_bin so that it
# gets compiled on an as-needed basis.
#
# This rule prints
# 'get_measure_memory_bin: path/to/measure/memory/utility'
# to STDOUT in the format native for the host OS. The prefix is needed to let
# Python distinguish between the result and all the warnings that b2 may print,
# because there's neither a way to turn these warnings of nor redirect them to
# STDERR. Really annoying.
notfile get_measure_memory_bin : @_get-measure-memory-binary
                               : measure_memory
                               : $(_measure_memory_requirements)
                               ;
explicit get_measure_memory_bin ;


# ------------------------------- Benchmarks -------------------------------- #

# Again, we defined common requirements
local _sort_array_requirements = 
           # Without this flag, Clang chokes at larger inputs
           <toolset>clang:<cxxflags>"-fconstexpr-steps=10000000" ;

# Sort an array during compilation
# Additional sort/ makes Boost.Build create an extra directory for this test
# case. It's useful when we have a lot of tests.
exe sort/sort_array : sort/sort_array.cpp 
                    : $(_sort_array_requirements)
                    ;
explicit sort/sort_array ;

rule _get-sort-array-path ( target : sources * : requirements * )
{
    local xs   = [ property-set.create $(requirements) ] ;
    local path = [ $(xs).target-path ] ;
    path = $(path[1]) ;
    ECHO "sort/get_prefix:"
        [ path.native bin/$(path)/sort ] ;
}

# Rule that prints the directory where the sort_array binary will be stored.
# This directory is also used by Python script to store benchmarks there.
notfile sort/get_prefix : @_get-sort-array-path
                        : sort/sort_array.cpp
                        : $(_sort_array_requirements) 
                        ;
explicit sort/get_prefix ;

