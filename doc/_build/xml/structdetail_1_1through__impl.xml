<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.8">
  <compounddef id="structdetail_1_1through__impl" kind="struct" prot="public">
    <compoundname>detail::through_impl</compoundname>
    <basecompoundref refid="structview__adaptor__base" prot="public" virt="non-virtual">view_adaptor_base&lt; through_impl&lt; View, Proxy &gt;, View &gt;</basecompoundref>
    <includes refid="through_8hpp" local="no">through.hpp</includes>
    <templateparamlist>
      <param>
        <type>class View</type>
      </param>
      <param>
        <type>class Proxy</type>
      </param>
    </templateparamlist>
      <sectiondef kind="private-attrib">
      <memberdef kind="variable" id="structdetail_1_1through__impl_1a406632ea055bdbe75400c415dac24d72" prot="private" static="no" mutable="no">
        <type>Proxy</type>
        <definition>Proxy detail::through_impl&lt; View, Proxy &gt;::_proxy</definition>
        <argsstring></argsstring>
        <name>_proxy</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/tom/GSoC2017/static-views/include/boost/static_views/through.hpp" line="113" column="1" bodyfile="/home/tom/GSoC2017/static-views/include/boost/static_views/through.hpp" bodystart="113" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-func">
      <memberdef kind="function" id="structdetail_1_1through__impl_1a59a419b455491c4c6cad516d35ab7333" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>constexpr</type>
        <definition>constexpr detail::through_impl&lt; View, Proxy &gt;::through_impl</definition>
        <argsstring>(View &amp;&amp;xs, Proxy &amp;&amp;proxy) BOOST_STATIC_VIEWS_NOEXCEPT_IF(utils</argsstring>
        <name>through_impl</name>
        <param>
          <type>View &amp;&amp;</type>
          <declname>xs</declname>
        </param>
        <param>
          <type>Proxy &amp;&amp;</type>
          <declname>proxy</declname>
        </param>
        <briefdescription>
<para>Constructs a view of <computeroutput>xs</computeroutput> through <computeroutput>proxy</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>View</parametername>
</parameternamelist>
<parameterdescription>
<para><verbatim>embed:rst:leading-slashes
/// Wrapper around a view, i.e. ``typename View::type`` is a view and
/// must model the :ref:`view &lt;view-concept&gt;` concept.
/// </verbatim> </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Proxy</parametername>
</parameternamelist>
<parameterdescription>
<para><verbatim>embed:rst:leading-slashes
/// Just like ``View``, a wrapper around a view, i.e.
/// ``typename Proxy::type`` must be a view. Furthermore, viewed
/// elements must be of type ``std::size_t``.
/// </verbatim> </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>xs</parametername>
</parameternamelist>
<parameterdescription>
<para>Rvalue reference to a wrapper around a view. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>proxy</parametername>
</parameternamelist>
<parameterdescription>
<para>Rvalue reference to a wrapper around a view. It is used as a proxy to access elements of <computeroutput>xs</computeroutput>, i.e. if <computeroutput>ys = <ref refid="structdetail_1_1through__impl" kindref="compound">through_impl</ref>{xs, proxy}</computeroutput>, then <formula id="13">\[ \text{ys}[i] = \text{xs.get}()\!\left[ \text{proxy.get}()[i]\right]\;, \forall i \in \{0,1,\dots,\text{xs.size}() - 1\}. \]</formula></para></parameterdescription>
</parameteritem>
</parameterlist>
<verbatim>embed:rst:leading-slashes
/// .. note::
///   It&apos;s annoying to have to specify the ``View`` and ``Proxy``
///   template parameters all the time. For this reason a
///   :cpp:var:`through` factory function is provided. Use it instead
///   to construct views through other views.
/// </verbatim> </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/tom/GSoC2017/static-views/include/boost/static_views/through.hpp" line="55" column="1" bodyfile="/home/tom/GSoC2017/static-views/include/boost/static_views/through.hpp" bodystart="55" bodyend="64"/>
      </memberdef>
      <memberdef kind="function" id="structdetail_1_1through__impl_1a2abb4dc480f21a570b67ba88f0e27f15" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>constexpr auto</type>
        <definition>constexpr auto detail::through_impl&lt; View, Proxy &gt;::size</definition>
        <argsstring>() const BOOST_STATIC_VIEWS_NOEXCEPT_IF(noexcept(std::declval&lt; Proxy const &amp; &gt;().get().size()))</argsstring>
        <name>size</name>
        <briefdescription>
<para>Returns the number of elements viewed. </para>        </briefdescription>
        <detaileddescription>
<para><verbatim>embed:rst:leading-slashes
/// This function is required by the :ref:`view &lt;view-concept&gt;`
/// concept. It just calls ``size()`` on the proxy view. This
/// function never fails unless a call to ``proxy.size()``
/// fails.
/// </verbatim> </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/tom/GSoC2017/static-views/include/boost/static_views/through.hpp" line="86" column="1" bodyfile="/home/tom/GSoC2017/static-views/include/boost/static_views/through.hpp" bodystart="86" bodyend="91"/>
      </memberdef>
      <memberdef kind="function" id="structdetail_1_1through__impl_1a12287017d830da1df38741cb7738a9fb" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>constexpr auto</type>
        <definition>constexpr auto detail::through_impl&lt; View, Proxy &gt;::map</definition>
        <argsstring>(std::size_t const i) const BOOST_STATIC_VIEWS_NOEXCEPT_IF(noexcept(std::declval&lt; Proxy const &amp; &gt;().get()[std::declval&lt; std::size_t &gt;()])) -&gt; std::size_t</argsstring>
        <name>map</name>
        <param>
          <type>std::size_t const</type>
          <declname>i</declname>
        </param>
        <briefdescription>
<para>&quot;Maps&quot; index <computeroutput>i</computeroutput> to the corresponding index in the parent view. Actually, it just calls <computeroutput>operator[]</computeroutput> on the proxy view. </para>        </briefdescription>
        <detaileddescription>
<para>Let <computeroutput>ys</computeroutput> be of type <ref refid="structdetail_1_1through__impl_1a59a419b455491c4c6cad516d35ab7333" kindref="member">through_impl</ref>, i.e. <computeroutput>ys =</computeroutput> <ref refid="through_8hpp_1a10a5a202e599a78286b05fa944a5407e" kindref="member">through</ref> <computeroutput>(proxy)(xs)</computeroutput>. The following relation then holds</para><para><computeroutput>ys.</computeroutput> <ref refid="structdetail_1_1through__impl_1a12287017d830da1df38741cb7738a9fb" kindref="member">map</ref> <computeroutput>(i) = proxy[i],</computeroutput> <formula id="14">$\forall i \in \{0, 1, \dots, \text{proxy.size}()-1\}.$</formula> </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/tom/GSoC2017/static-views/include/boost/static_views/through.hpp" line="102" column="1" bodyfile="/home/tom/GSoC2017/static-views/include/boost/static_views/through.hpp" bodystart="102" bodyend="109"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-static-func">
      <memberdef kind="function" id="structdetail_1_1through__impl_1ab1f324f4aa5559fe457ec39ecb6abbc8" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>constexpr auto</type>
        <definition>static constexpr auto detail::through_impl&lt; View, Proxy &gt;::capacity</definition>
        <argsstring>() noexcept</argsstring>
        <name>capacity</name>
        <briefdescription>
<para>Returns the capacity of this view. </para>        </briefdescription>
        <detaileddescription>
<para><verbatim>embed:rst:leading-slashes
/// This function is required by the :ref:`view &lt;view-concept&gt;`
/// concept. It just calls ``capacity()`` on the proxy view. This
/// function never fails.
/// </verbatim> </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/tom/GSoC2017/static-views/include/boost/static_views/through.hpp" line="73" column="1" bodyfile="/home/tom/GSoC2017/static-views/include/boost/static_views/through.hpp" bodystart="73" bodyend="76"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <inheritancegraph>
      <node id="183">
        <label>view_base</label>
        <link refid="structview__base"/>
      </node>
      <node id="182">
        <label>view_adaptor_base&lt; through_impl&lt; View, Proxy &gt;, View &gt;</label>
        <link refid="structview__adaptor__base"/>
        <childnode refid="183" relation="public-inheritance">
        </childnode>
      </node>
      <node id="181">
        <label>detail::through_impl&lt; View, Proxy &gt;</label>
        <link refid="structdetail_1_1through__impl"/>
        <childnode refid="182" relation="public-inheritance">
        </childnode>
      </node>
    </inheritancegraph>
    <collaborationgraph>
      <node id="186">
        <label>view_base</label>
        <link refid="structview__base"/>
      </node>
      <node id="185">
        <label>view_adaptor_base&lt; through_impl&lt; View, Proxy &gt;, View &gt;</label>
        <link refid="structview__adaptor__base"/>
        <childnode refid="186" relation="public-inheritance">
        </childnode>
      </node>
      <node id="184">
        <label>detail::through_impl&lt; View, Proxy &gt;</label>
        <link refid="structdetail_1_1through__impl"/>
        <childnode refid="185" relation="public-inheritance">
        </childnode>
      </node>
    </collaborationgraph>
    <location file="/home/tom/GSoC2017/static-views/include/boost/static_views/through.hpp" line="23" column="1" bodyfile="/home/tom/GSoC2017/static-views/include/boost/static_views/through.hpp" bodystart="23" bodyend="114"/>
    <listofallmembers>
      <member refid="structdetail_1_1through__impl_1a406632ea055bdbe75400c415dac24d72" prot="private" virt="non-virtual"><scope>detail::through_impl</scope><name>_proxy</name></member>
      <member refid="structdetail_1_1through__impl_1ab1f324f4aa5559fe457ec39ecb6abbc8" prot="public" virt="non-virtual"><scope>detail::through_impl</scope><name>capacity</name></member>
      <member refid="structdetail_1_1through__impl_1a12287017d830da1df38741cb7738a9fb" prot="public" virt="non-virtual"><scope>detail::through_impl</scope><name>map</name></member>
      <member refid="structview__adaptor__base_1a9fead4eeb8ce03baaa1b232c4cea0e8e" prot="public" virt="non-virtual"><scope>detail::through_impl</scope><name>operator=</name></member>
      <member refid="structview__adaptor__base_1a22143f370952734cf4c80659929874b9" prot="public" virt="non-virtual"><scope>detail::through_impl</scope><name>operator=</name></member>
      <member refid="structview__adaptor__base_1a7c477df3bdd93b8f8983325006ed4f27" prot="public" virt="non-virtual"><scope>detail::through_impl</scope><name>operator[]</name></member>
      <member refid="structview__adaptor__base_1a0c839ea46bad2e630109fdacc47c2df8" prot="public" virt="non-virtual"><scope>detail::through_impl</scope><name>operator[]</name></member>
      <member refid="structview__adaptor__base_1a844c5f4446e821d074bbc17977149561" prot="public" virt="non-virtual"><scope>detail::through_impl</scope><name>operator[]</name></member>
      <member refid="structview__adaptor__base_1a767124ab23a20fded7bc6edb7cbcaac1" prot="public" virt="non-virtual"><scope>detail::through_impl</scope><name>parent</name></member>
      <member refid="structview__adaptor__base_1a5a27d8dea803e58a7699ca7189941cca" prot="public" virt="non-virtual"><scope>detail::through_impl</scope><name>parent</name></member>
      <member refid="structdetail_1_1through__impl_1a2abb4dc480f21a570b67ba88f0e27f15" prot="public" virt="non-virtual"><scope>detail::through_impl</scope><name>size</name></member>
      <member refid="structdetail_1_1through__impl_1a59a419b455491c4c6cad516d35ab7333" prot="public" virt="non-virtual"><scope>detail::through_impl</scope><name>through_impl</name></member>
      <member refid="structview__adaptor__base_1a081ca186c301145c8ca08674c9c83702" prot="public" virt="non-virtual"><scope>detail::through_impl</scope><name>view_adaptor_base</name></member>
      <member refid="structview__adaptor__base_1a95d73d5dea98d1d9fb667e0de3d2db20" prot="public" virt="non-virtual"><scope>detail::through_impl</scope><name>view_adaptor_base</name></member>
      <member refid="structview__adaptor__base_1a6b801b834ff65616ebd0b201bf2ccb08" prot="public" virt="non-virtual"><scope>detail::through_impl</scope><name>view_adaptor_base</name></member>
      <member refid="structview__adaptor__base_1a5a4854293c96582b2a65d3db30c9ce4c" prot="protected" virt="non-virtual"><scope>detail::through_impl</scope><name>view_adaptor_base_type</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
